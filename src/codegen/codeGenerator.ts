/**
 * Generates TypeScript code from recorded actions.
 * Outputs multiple selector variants for each action to allow AI post-processing.
 */

import { writeFileSync } from 'node:fs';
import type { RecordedAction, SelectorVariant } from './types.js';

export class CodeGenerator {
  private readonly actions: RecordedAction[] = [];
  private readonly outputPath: string;
  private actionCounter = 0;
  private apiKeySelector: string | undefined;

  constructor(outputPath: string) {
    this.outputPath = outputPath;
  }

  addAction(action: RecordedAction): void {
    this.actions.push(action);
    this.flush();
  }

  setApiKeySelector(selector: string): void {
    this.apiKeySelector = selector;
    this.flush();
  }

  private escapeString(str: string): string {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r');
  }

  private generateLocatorCall(selector: string, actionMethod: string): string {
    return `await page.locator('${this.escapeString(selector)}').${actionMethod}`;
  }

  private generateActionCode(action: RecordedAction): string {
    // Navigation doesn't need selector variants
    if (action.type === 'navigate') {
      return `  await page.goto('${this.escapeString(action.url ?? '')}');`;
    }

    // Get selector variants or create a single variant from the primary selector
    const variants: readonly SelectorVariant[] = action.selectorVariants ??
      (action.selector ? [{ type: 'fallback' as const, selector: action.selector }] : []);

    if (variants.length === 0) {
      return `  // Action ${action.type} with no selector`;
    }

    // Determine the action method based on type
    let actionMethod: string;
    switch (action.type) {
      case 'click':
        actionMethod = 'click();';
        break;
      case 'fill':
        actionMethod = `fill('${this.escapeString(action.value ?? '')}');`;
        break;
      case 'press':
        actionMethod = `press('${this.escapeString(action.key ?? '')}');`;
        break;
      case 'select':
        actionMethod = `selectOption('${this.escapeString(action.value ?? '')}');`;
        break;
      case 'check':
        actionMethod = 'check();';
        break;
      case 'uncheck':
        actionMethod = 'uncheck();';
        break;
      default: {
        const unknownType: never = action.type;
        return `  // Unknown action: ${String(unknownType)}`;
      }
    }

    this.actionCounter++;
    const actionId = this.actionCounter;

    // Generate code with all variants clearly marked for AI post-processing
    const lines: string[] = [];
    lines.push(`  // ===== ACTION ${String(actionId)} START: ${action.type} =====`);
    lines.push(`  // AI: Pick ONE of the following selector variants for this ${action.type} action.`);
    lines.push(`  // Delete the others and remove the comment markers.`);

    for (const variant of variants) {
      const variantLabel = variant.type.toUpperCase();
      const code = this.generateLocatorCall(variant.selector, actionMethod);
      lines.push(`  // VARIANT [${variantLabel}]: ${code}`);
    }

    // Add the primary selector as the active line (for immediate executability)
    const primaryVariant = variants[0];
    if (primaryVariant) {
      lines.push(`  ${this.generateLocatorCall(primaryVariant.selector, actionMethod)} // ACTIVE - using ${primaryVariant.type.toUpperCase()}`);
    }

    lines.push(`  // ===== ACTION ${String(actionId)} END =====`);
    lines.push('');

    return lines.join('\n');
  }

  generateCode(): string {
    // Reset counter for consistent output
    this.actionCounter = 0;

    const header = `// Generated by Latchkey Codegen
// This file contains multiple selector variants for each action.
// An AI post-processor should select the most appropriate selector for each action.
// Look for "===== ACTION N START =====" blocks and pick one VARIANT per action.

const { chromium } = require('playwright');

(async () => {
  const browser = await chromium.launch({ headless: false });
  const context = await browser.newContext();
  const page = await context.newPage();

`;

    const footer = `  // ---------------------
  await context.close();
  await browser.close();
})();
`;

    const actionLines = this.actions.map((action) => this.generateActionCode(action));

    // Generate API key extraction code if selector was set
    let apiKeyCode = '';
    if (this.apiKeySelector) {
      apiKeyCode = `
  // ===== API KEY EXTRACTION =====
  const apiKey = await page.locator('${this.escapeString(this.apiKeySelector)}').textContent();
  console.log('API Key:', apiKey);
  // ===== END API KEY EXTRACTION =====

`;
    }

    return header + actionLines.join('\n') + apiKeyCode + footer;
  }

  flush(): void {
    writeFileSync(this.outputPath, this.generateCode(), 'utf-8');
  }
}
